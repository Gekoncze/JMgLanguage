### DONE ### -----------------------------------------------------------------------------------------------------------
improved resolve component tasks
found proper place for add buildin components and resolve usages tasks
added operator to logical function
added build operator (for function header) task


### NOW ### ------------------------------------------------------------------------------------------------------------
function resolution
    resolve instructions
        command resolver
            resolve operators and build a tree with respect to operator priorities
            expression resolver
            mg command to instruction converter
            add more instructions

take into account access modifiers during resolve

resolver + logical to runtime converter
    1# add buildin components
    2# create empty runtime components
    3# resolution of usages
    4# resolution of stamps
    5# resolution of components
    6# resolution of instructions

fix runtime test


### SOON ### -----------------------------------------------------------------------------------------------------------
make MgCore work
move all subtasks to Task class ???
how to handle nulls and what will be their syntax?
    probably as a buildin component

add support for global variables ?
    in logical class the field is already prepared, but I dont know if it is actually used during build

mg add support for relative "../" usages ???
mg add support for multiple (star) usages - is it going to be just a syntactical sugar?

add support for operator definitions
    operators are build on top of functions, as an optional syntactical sugar
    you should still be able to call the function by its name with parameters
    investigate the best way how to express it in the mg language
    add builder for it
    priority can be set in the definition too
    how to import the operators ???

add support for variable number of parameters of functions ?

think about runtime and logical high-level architecture
    modules or bundles or libraries or packages ...
        we could take a look at locations as folders/directories in os
        packages would be like installer packages in os
        components would be like files in os

    implement logic for loading modules/bundles/libraries/package

mg collection definitions
    they should definitely be distinguished as readable, writeable, readonly, nonnull somehow

mg stamps definitions
    additional information for the compiler
    can be mandatory or optional ?
        for mandatory stamps, the compiler has to throw an error if it cannot handle them

think about static variables, we might want these to supply enums
    where will those be stored in at runtime? in classes directly maybe?


### LATER ### ----------------------------------------------------------------------------------------------------------
mg logic entity versioning ?
mg runtime entity versioning ?

think of possible scheduler
    schedulers can schedule:
        for each core a bunch of threads
        a bunch of threads for bunch of cores
        ... the question there is, if scheduler should be inside of core or application ?

c entities
    add global variable element (dont forget modifiers)
    add thread local modifier
    add extern modifier
    add (c language specific) static modifier
    differentiate c number and text and character literals ???

    bad design detected
        lines should own tokens as a part
        but actually, with static final variables, they cant own them, they just reference them
        the right thing to do is to always create a new token instance!

write mg to c converter (logic or runtime?)

c writer
    optimize operator writer tasks to not always include brackets

function pointers in mg - will be called interfaces (java like interfaces might be called roles)

improve exceptions
    add more exception types
    add some kind of tracing
        how to trace origin for error messages?
            1) might use optional setter, that shall be set for all newly created objects
                origin would be taken from one of the input objects
            2) shouldnt a stack trace be enough? implying we have a tree of entities


### MAYBE LATER ### ----------------------------------------------------------------------------------------------------
limit file size parameter
add entity validations

mg language - required vs optional input and output variables for functions
    can be implemented as syntactical sugar


### IDEAS ### ----------------------------------------------------------------------------------------------------------
very interesting idea
    contextual methods
        entities can have different methods based on current context
            ie CStructure in c to java converter context will have different methods than in c to php converter context
    these can also support overriding
    in each file, we might need to specify context, or specify it in some other way?
    this might also be accomplished by special "inheritance"
        mg will have more types of inheritance: IS <-, LIKE >-<, AS <->, VIEW ->

    find out how to mimic contextual methods in java?
        maybe we are overreacting now, lets make one simple implementation for our case
        and then we can take care of the remaining scenarios!
        keep this java implementation as simple as possible!

        also, think about difference between dependency injection and contextual methods

aliases for modules in application - ie remapping module locations
    this step would probably take in place after the module itself and its dependencies are resolved

if operator
