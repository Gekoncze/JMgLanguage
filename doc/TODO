### DONE ### -----------------------------------------------------------------------------------------------------------
significant architectural changes, part #1
changed many abstract classes into interfaces
work in progress ...


### NOW ### ------------------------------------------------------------------------------------------------------------
see rules for possible architectural changes
all mg entities should implement MgEntity
all c entities should implement CEntity

mg text entities to mg entites
    ... an interesting idea
        there are groups of keywords following each other, always at the beginning, for example DEFINE CLASS
            then follows no keywords, for example DEFINE CLASS FooBar
                but jsut in case keyword follows, it is interpreted as if it was a child block, for example:
                    DEFINE CLASS FooBar IS Bar
                    is the same as
                    DEFINE CLASS FooBar
                        IS Bar
            the same could be with stamps, for example:
                @public DEFINE CLASS FooBar
                is the same as
                @public
                DEFINE CLASS FooBar

            so, there would be two steps in between
                keyword block arrangement
                stamp block arrangement

    mg structured text entity builders
        part builder ... todo
            maybe change the way how builders work
                it would be better, if there was input as begin and end
                    begin - the first item from which to start scanning
                    end - the last item that include in scanning
                        NEED TO TAKE CARE THOUGH! cuz one could simply call get next on end and get out of bounds
                            this could be handled by some kind of builder wrapper

            operator merger - merge symbols that are close to each other and are not brackets or stamps
            bracket builder
            chain builder
            operator builder
            keyword grouper - keywords can be only toplevel, not inside groups

remove c tokens

add more instructions
... is application instance of module?

write the logic for loading modules:
    application will load modules with unresolved classes
    at the very end, application will resolve the classes
    after the resolve, it will create instructions for functions


### SOON ### -----------------------------------------------------------------------------------------------------------
think about mg collections
    they should definitely be distinguished as readable or writeable or both

there should be strictly distingushed examples sugar and actual language entities
    needs to think a lot about their purpose
    for example function call with expression as parameter could be one, but also dont have to be!

think about static variables, we might want these to supply enums
    those will be stored in the runtime classes, right?

think of possible scheduler
    also think if current architecture is good
    maybe I will postpone schedulers for later ... or now will just make simple round robin one!
    schedulers can schedule:
        for each core a bunch of threads
        a bunch of threads for bunch of cores
        ... the question there is, if scheduler should be inside of core or application ?

mg parser/builder
    write mg parser -- I mean, move it here from previous project
    write mg builder -- this one can also move mostly from previous project

    An interesting idea for parser !!!
        there is a problem with syntax for INPUT, OUTPUT, IS and other inner lists of definitions
            maybe, just maybe, it could be as there are inside objects specified either
                with keyword - INPUT objects of a function for example
                without keyword - commands of a function for example
            and then there will be a rule, that keyword objects can be appended to definition line!
            would this be easy to implement?
            would this be intuitive?

    how to deal with objects being in separate files?
        1) they can have a target parent specified
            how to resolve the target though? -- there is no context yet!
        2) classical tree structure - parents will have list of children
            each module will have a list of files or locations/directories

        default target location will be root location of default module


### LATER ### ----------------------------------------------------------------------------------------------------------
c entities
    add global variable element (dont forget modifiers)
    add thread local modifier
    add extern modifier
    add (c language specific) static modifier
    differentiate c number and text and character literals ???

    bad design detected
        lines should own tokens as a part
        but actually, with static final variables, they cant own them, they just reference them
        the right thing to do is to always create a new token instance!

write mg to c converter

function pointers - might need to add function type
how to trace origin? might use optional setter, that shall be set for all newly created objects
    origin will be taken from one of the input objects
        ... shouldnt a stack trace be enough? implying we have a tree of entities
add entity assertation class with entity assertation exception


### IDEAS ### ----------------------------------------------------------------------------------------------------------
very interesting idea
    contextual methods
        entities can have different methods based on current context
            ie CStructure in c to java converter context will have different methods than in c to php converter context
    these can also support overriding
    in each file, we might need to specify context, or specify it in some other way?
    this might also be accomplished by special "inheritance"
        mg will have more types of inheritance: IS <-, LIKE >-<, AS <->, VIEW ->

limit file size parameter
limit file location to project folder only ?
aliases for modules in mgapplication ?

object model
    pointer to its class definition
    list of data storages - each data storage belongs to certain class in inheritance
    class definition contains list of functions

    objects should be able to be aliased
        aliases are two way exchangable
        aliases can have aditional methods, but not aditional data
        maybe those methods can even be overriden

mg language - required and/or optional input and output (probably with stamps)
transparent work with collections and (non-nullable / nullable) objects - if possible
be it only a library yet, ie no project file, for simplicity
optimize operator writer tasks to not always include brackets

add compiler parameters for cproject ?
ideas mg groups - classes can belong to one or more groups
    something like multiple inheritance

do not allow escape sequences or anythign like that
    use special buildin constants or functions
    this will simplify literal handling A LOT

ALL mg paths to be completely relative, or absolute being relative to module

find out how to mimic contextual methods in java?
    maybe we are overreacting now, lets make one simple implementation for our case
    and then we can take care of the remaining scenarios!
    keep this java implementation as simple as possible!

    also, think about difference between dependency injection and contextual methods

if, then, and, or operators ?