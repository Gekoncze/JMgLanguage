### DONE ### -----------------------------------------------------------------------------------------------------------


### NOW ### ------------------------------------------------------------------------------------------------------------
another problem with contexts
    I think that when creting class resolver for example, there is missing a root context - cerify
    it seems that root context is unused anyway, search if it could be created indirectly somehow
    this is related to the problem with contexts aliases below
    actually, I think that this is handled by component context, which should be created in the abstract task
    so only root context creation is missing somewhere?

problem with contexts
    aliases are not handled correctly
    components are imported with their real names
    but in code we try to refer to them using an alias
    this way we will not find aliases
    there has to be some special kind of alias handling mechanism for names
    I think that context for each component has to have name as mandatory
    and all components must have name anyway
    operators should not allow aliases
    after this is resolved, we should be able to handle also to-do in collection context

while onto resolving problems with contexts, take a look at:
    take into account access modifiers during resolve
    add support for aliases in usages if not already
    add support for relative "../" usages ???
    add support for multiple (star) usages - is it going to be just a syntactical sugar?

reimplement command resolvers
    commands need to have special expression resolver which will provide node with expected datatype

literal values
    always return text
    provide feature for implicit conversion of literals
    conversion using *as* operator

    idea - there can be two types:
        '' - converted at startup when code is loaded
        "" - converted at runtime during expression execution

    there will be buildin converters for buildin types
    user should be able to provide his own converters for his own types

test
    test what expression like this will do:
        (a * b)(c, d, e)
        what error will be thrown?
        this is something like a parametrized call, but without a name on the left


### SOON ### -----------------------------------------------------------------------------------------------------------
implementation of the new simplified runtime model
    we might need a context object being passed
        passed in two ways:
            implicitly - current function context will be used
            explicitly - user provided context will be used

think about new object creation
    there would be probably some default allocator
    and default factory, which would automatically call function
        with stamps like @create @destroy

complete support for collections
    for resolve, MgParameter needs to be a type/component (see to do in CollectionContext)
    they should definitely be distinguished as readable, writeable, readonly, nonnull somehow

add support for variable number of parameters of functions ?

high-level architecture
    modules or bundles or libraries or packages ...
        we could take a look at locations as folders/directories in os
        packages would be like installer packages in os
        components would be like files in os
    how would this be solved on both logical and runtime level?

mg stamps definitions
    additional information for the compiler or during runtime
    when used, the "instances" cannot hold any values, those will be just references to the definition
    can be mandatory or optional ? or maybe it could be called critical or something like that
        for mandatory stamps, the compiler has to throw an error if it cannot handle them
            I dont actually know how much the compiler should be handling those...
                maybe its not a good idea, investigate


### LATER ### ----------------------------------------------------------------------------------------------------------
add context for function execution

change static create implementations
    make it so the classes registers themselves in a static block

mg logic entity versioning ?
mg runtime entity versioning ?
mg global variable - add runtime validation for type?
mg member variable - add runtime validation for type?

think of possible scheduler
    schedulers can schedule:
        for each core a bunch of threads
        a bunch of threads for bunch of cores
        ... the question there is, if scheduler should be inside of core or application ?

c entities
    add global variable element (dont forget modifiers)
    add thread local modifier
    add extern modifier
    add (c language specific) static modifier
    differentiate c number and text and character literals ???

    bad design detected
        lines should own tokens as a part
        but actually, with static final variables, they cant own them, they just reference them
        the right thing to do is to always create a new token instance!

write mg to c converter (logic or runtime?)

c writer
    optimize operator writer tasks to not always include brackets

function pointers in mg - will be called interfaces (java like interfaces might be called roles)

improve compiler exceptions
    add external (user) exception vs internal exception
    add more exception types
    add some kind of tracing
        how to trace origin for error messages?
            1) might use optional setter, that shall be set for all newly created objects
                origin would be taken from one of the input objects
            2) shouldnt a stack trace be enough? implying we have a tree of entities

make platform independent threads
    this will require:
        more effort from my side
        generating instructions for functions from its commands and expressions
        add MgThread and MgCore objects
    this will allow:
        more flexibility
        any number of threads in application
        easier manipulation (thread can be started, paused, stopped, etc)
        better memory management (not so much on stack, more on heap)
    not sure:
        if better or worse performance

make MgCore work


### MAYBE LATER ### ----------------------------------------------------------------------------------------------------
limit file size parameter
add entity validations
during resolution, inner context cannot shadow outer context results
during resolution, some local variables created by expressions can be reused

mg language - required vs optional input and output variables for functions
    can be implemented as syntactical sugar

move all subtasks to Task class ???

(global) function and variable overriding
    VARIABLE Int32 foo
    vs
    OVERRIDE foo VARIABLE Int32 bar
    vs
    VARIABLE Int32 bar OVERRIDE foo
    -
    FUNCTION foo INPUT ... OUTPUT ...
    vs
    OVERRIDE foo FUNCTION bar INPUT ... OUTPUT ...
    vs
    FUNCTION bar INPUT ... OUTPUT ... OVERRIDE foo


### IDEAS ### ----------------------------------------------------------------------------------------------------------
very interesting idea
    contextual methods
        entities can have different methods based on current context
            ie CStructure in c to java converter context will have different methods than in c to php converter context
    these can also support overriding
    in each file, we might need to specify context, or specify it in some other way?
    this might also be accomplished by special "inheritance"
        mg will have more types of inheritance: IS <-, LIKE >-<, AS <->, VIEW ->

    find out how to mimic contextual methods in java?
        maybe we are overreacting now, lets make one simple implementation for our case
        and then we can take care of the remaining scenarios!
        keep this java implementation as simple as possible!

        also, think about difference between dependency injection and contextual methods

aliases for modules in application - ie remapping module locations
    this step would probably take in place after the module itself and its dependencies are resolved

if ternary operator ?
