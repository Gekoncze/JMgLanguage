### DONE ### -----------------------------------------------------------------------------------------------------------
added expression filter + matcher improvements
work in progress ...


### NOW ### ------------------------------------------------------------------------------------------------------------
we might need to somehow add offset to the passed parent expression parameter ...
    we might then need to do some optional matching
        so at lest one variable has to match and this will be used to connect to the parent
            add a connect method maybe?
            how to handle operator replication?

function resolution
    resolve instructions
        command resolver
            to do:
                might need to pass output variables to expression resolve tasks as input ...
                    this might be required so they can tighten the return value set

                resolve operators and build a tree with respect to operator priorities
                expression resolver
                mg command to instruction converter
            I have an idea
                each expression element will:
                    1) generate instructions and variables into node (variables without names, and without type (if possible))
                    2) return a list of return values - indexes of local variables

            function resolution
                will be from leaves to root
                I will see in the future if can be in opposite direction too and under which conditions
                    this could be achieved by first resolution from root to leaves
                    and then resolution from leaves to root
                    at each moment we wil check what we have available and search and filter based on that
                        if a single match is made, we select it as target object
                        if no match, then we throw an error
                        if multiple matches then
                            if root to leave resolution, we skip and continue
                            if leaf to root resolution, we throw an ambiguous error

            store literal values in function global variables
                how to handle converters for literals? when are those called? at startup?

            how to store expression variables in function?
                they cannot have separate list, because they are located by index in instructions as regular variables
                they will be stored probably at the end, after input, output and locals
                    will need to pass starting index at a point where the index is stored in instruction

            path resolution
                context need to be changed only for root expression

change mg types into class objects
    then inside they could have an optional type definition
    which would contain variable declarations
    this way we could get rid of mg global variable class
    or we could just rename them to type variables and handle them differently in text and data structures
    will need to think a bit more about type inheritance for both variables and functions

add support for function overriding - alternative implementation of function table

take into account access modifiers during resolve
fix runtime test

mg operator replication
    list part / list expression would "return multiple values"
    if input and ouptut lists matches, then operator is called for each corresponding input/output pair


### SOON ### -----------------------------------------------------------------------------------------------------------
make MgCore work
think about new object creation
    there would be probably some default allocator
    and default factory, which would automatically call function
        with stamps like @create @destroy

complete support for collections
    for resolve, MgParameter needs to be a type/component (see to do in CollectionContext)
    they should definitely be distinguished as readable, writeable, readonly, nonnull somehow

mg add support for relative "../" usages ???
mg add support for multiple (star) usages - is it going to be just a syntactical sugar?

add support for operator definitions
    operators are build on top of functions, as an optional syntactical sugar
    you should still be able to call the function by its name with parameters
    investigate the best way how to express it in the mg language
    add builder for it
    priority can be set in the definition too
    how to import the operators ???

add support for variable number of parameters of functions ?

high-level architecture
    modules or bundles or libraries or packages ...
        we could take a look at locations as folders/directories in os
        packages would be like installer packages in os
        components would be like files in os
    how would this be solved on both logical and runtime level?

mg stamps definitions
    additional information for the compiler or during runtime
    when used, the "instances" cannot hold any values, those will be just references to the definition
    can be mandatory or optional ? or maybe it could be called critical or something like that
        for mandatory stamps, the compiler has to throw an error if it cannot handle them


### LATER ### ----------------------------------------------------------------------------------------------------------
mg logic entity versioning ?
mg runtime entity versioning ?
mg global variable - add runtime validation for type?
mg member variable - add runtime validation for type?

think of possible scheduler
    schedulers can schedule:
        for each core a bunch of threads
        a bunch of threads for bunch of cores
        ... the question there is, if scheduler should be inside of core or application ?

c entities
    add global variable element (dont forget modifiers)
    add thread local modifier
    add extern modifier
    add (c language specific) static modifier
    differentiate c number and text and character literals ???

    bad design detected
        lines should own tokens as a part
        but actually, with static final variables, they cant own them, they just reference them
        the right thing to do is to always create a new token instance!

write mg to c converter (logic or runtime?)

c writer
    optimize operator writer tasks to not always include brackets

function pointers in mg - will be called interfaces (java like interfaces might be called roles)

improve compiler exceptions
    add more exception types
    add some kind of tracing
        how to trace origin for error messages?
            1) might use optional setter, that shall be set for all newly created objects
                origin would be taken from one of the input objects
            2) shouldnt a stack trace be enough? implying we have a tree of entities


### MAYBE LATER ### ----------------------------------------------------------------------------------------------------
limit file size parameter
add entity validations
during resolution, inner context cannot shadow outer context results

mg language - required vs optional input and output variables for functions
    can be implemented as syntactical sugar

move all subtasks to Task class ???
    we could then have execute and try to execute methods


### IDEAS ### ----------------------------------------------------------------------------------------------------------
very interesting idea
    contextual methods
        entities can have different methods based on current context
            ie CStructure in c to java converter context will have different methods than in c to php converter context
    these can also support overriding
    in each file, we might need to specify context, or specify it in some other way?
    this might also be accomplished by special "inheritance"
        mg will have more types of inheritance: IS <-, LIKE >-<, AS <->, VIEW ->

    find out how to mimic contextual methods in java?
        maybe we are overreacting now, lets make one simple implementation for our case
        and then we can take care of the remaining scenarios!
        keep this java implementation as simple as possible!

        also, think about difference between dependency injection and contextual methods

aliases for modules in application - ie remapping module locations
    this step would probably take in place after the module itself and its dependencies are resolved

if operator
