### DONE ### -----------------------------------------------------------------------------------------------------------
added expression block builder
fixed builder patterns - forgot to add keywords
cleanup of logical expression entities


### NOW ### ------------------------------------------------------------------------------------------------------------
structured text entities to logical entities
    add more build tasks ...
        block
            function
                commands
        part
            expression

        add helper build list block task


### SOON ### -----------------------------------------------------------------------------------------------------------
refactor runtime mg entities
    all runtime mg entities should extend MgObject which should extend MgEntity
    logical mg entities should only serve as a "template" for actual runtime objects

resolver
    resolution of logical entity usages
    resolution of operators and additional build steps based on priority
        priority can be choosen by the user
        operators need to be imported

nullable type specifier "?" in logical (and runtime?) mg entities
mg relative vs absolute usages
mg logical to runtime entities
add more instructions
implement logic for loading modules
use cache for usages during resolve to prevent multiple resolution of the same name
    cache should also contain other information like the expected type of the object (class, stamp, function, etc.)

think about mg collections
    they should definitely be distinguished as readable or writeable or both somehow

think about static variables, we might want these to supply enums
    those will be stored in the runtime classes, right?

runtime and logical architecture
    modules or bundles or libraries or packages ...
        we could take a look at locations as folders/directories in os
        packages would be like installer packages in os
        components would be like files in os


### LATER ### ----------------------------------------------------------------------------------------------------------
mg logic entity version
mg runtime entity version

think of possible scheduler
    also think if current architecture is good
    maybe I will postpone schedulers for later ... or now will just make simple round robin one!
    schedulers can schedule:
        for each core a bunch of threads
        a bunch of threads for bunch of cores
        ... the question there is, if scheduler should be inside of core or application ?

c entities
    add global variable element (dont forget modifiers)
    add thread local modifier
    add extern modifier
    add (c language specific) static modifier
    differentiate c number and text and character literals ???

    bad design detected
        lines should own tokens as a part
        but actually, with static final variables, they cant own them, they just reference them
        the right thing to do is to always create a new token instance!

write mg to c converter (logic or runtime?)

function pointers - might need to add function type

how to trace origin for error messages?
    1) might use optional setter, that shall be set for all newly created objects
        origin would be taken from one of the input objects
    2) shouldnt a stack trace be enough? implying we have a tree of entities

stamps
    additional information for the compiler
    can be mandatory or optional ?
        for mandatory stamps, the compiler has to throw an error if it cannot handle them


### IDEAS ### ----------------------------------------------------------------------------------------------------------
add entity assertation class with entity assertation exception ???
very interesting idea
    contextual methods
        entities can have different methods based on current context
            ie CStructure in c to java converter context will have different methods than in c to php converter context
    these can also support overriding
    in each file, we might need to specify context, or specify it in some other way?
    this might also be accomplished by special "inheritance"
        mg will have more types of inheritance: IS <-, LIKE >-<, AS <->, VIEW ->

    find out how to mimic contextual methods in java?
        maybe we are overreacting now, lets make one simple implementation for our case
        and then we can take care of the remaining scenarios!
        keep this java implementation as simple as possible!

        also, think about difference between dependency injection and contextual methods

limit file size parameter
limit file location to project folder only ?
aliases for modules in application - ie remapping module locations
    this step would probably take in place after the module itself and its dependencies are resolved

object model
    pointer to its class definition
    list of data storages - each data storage belongs to certain class in inheritance
    class definition contains list of functions

    objects should be able to be aliased
        aliases are two way exchangable
        aliases can have aditional methods, but not aditional data
        maybe those methods can even be overriden

mg language - required and/or optional input and output (probably with stamps)
transparent work with collections and (non-nullable / nullable) objects - if possible
be it only a library yet, ie no project file, for simplicity
optimize operator writer tasks to not always include brackets

add compiler parameters for cproject ?
ideas mg groups - classes can belong to one or more groups
    something like multiple inheritance

do not allow escape sequences or anythign like that
    use special buildin constants or functions
    this will simplify literal handling A LOT

ALL mg paths to be completely relative, or absolute being relative to module

if, then, and, or operators ?